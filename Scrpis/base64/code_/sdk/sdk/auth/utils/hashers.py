# """Django 2.0.7 密码 Hasher"""
# import base64
# import datetime
# import hashlib
# import math
# import secrets
# import string
# from decimal import Decimal
# from typing import Any, Dict, Optional, Union

# UNUSABLE_PASSWORD_PREFIX = "!"  # This will never be a valid encoded hash
# UNUSABLE_PASSWORD_SUFFIX_LENGTH = 40  # number of random chars to add after UNUSABLE_PASSWORD_PREFIX
# RANDOM_STRING_CHARS = (
#     string.ascii_lowercase + string.ascii_uppercase + string.digits
# )  # abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
# PROTECTED_TYPES = (type(None), int, float, Decimal, datetime.datetime, datetime.date, datetime.time)


# def check_password(password: str, encoded: str) -> bool:
#     """
#     Return a boolean of whether the raw password matches the three
#     part encoded digest.

#     If setter is specified, it'll be called when you need to
#     regenerate the password.
#     """
#     if password is None or not is_password_usable(encoded):
#         return False

#     return PBKDF2PasswordHasher().verify(password, encoded)


# def make_password(password: str, salt: Optional[str] = None) -> str:
#     """
#     Turn a plain-text password into a hash for database storage

#     Same as encode() but generate a new random salt. If password is None then
#     return a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string,
#     which disallows logins. Additional random string reduces chances of gaining
#     access to staff or superuser accounts. See ticket #20079 for more info.
#     """
#     if password is None:
#         return UNUSABLE_PASSWORD_PREFIX + get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH)
#     if not isinstance(password, (bytes, str)):
#         raise TypeError("Password must be a string or bytes, got %s." % type(password).__qualname__)
#     hasher = PBKDF2PasswordHasher()
#     salt = salt or hasher.salt()
#     return hasher.encode(password, salt)


# def is_password_usable(encoded: str) -> bool:
#     """
#     Return True if this password wasn't generated by
#     User.set_unusable_password(), i.e. make_password(None).
#     """
#     return encoded is None or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)


# def get_random_string(length: int = 12, allowed_chars: str = RANDOM_STRING_CHARS) -> str:
#     """
#     Return a securely generated random string.

#     The bit length of the returned value can be calculated with the formula:
#         log_2(len(allowed_chars)^length)

#     For example, with default `allowed_chars` (26+26+10), this gives:
#       * length: 12, bit length =~ 71 bits
#       * length: 22, bit length =~ 131 bits
#     """
#     return "".join(secrets.choice(allowed_chars) for _ in range(length))


# def constant_time_compare(val1: str, val2: str) -> bool:
#     """Return True if the two strings are equal, False otherwise."""
#     return secrets.compare_digest(force_bytes(val1), force_bytes(val2))


# def force_bytes(s: Union[str, bytes], encoding: str = "utf-8", strings_only: bool = False, errors: str = "strict") -> bytes:
#     """
#     Similar to smart_bytes, except that lazy instances are resolved to
#     strings, rather than kept as lazy objects.

#     If strings_only is True, don't convert (some) non-string-like objects.
#     """
#     # Handle the common case first for performance reasons.
#     if isinstance(s, bytes):
#         if encoding == "utf-8":
#             return s
#         else:
#             return s.decode("utf-8", errors).encode(encoding, errors)
#     if strings_only and is_protected_type(s):
#         return s
#     if isinstance(s, memoryview):
#         return bytes(s)
#     return str(s).encode(encoding, errors)


# def is_protected_type(obj: Any) -> bool:
#     """Determine if the object instance is of a protected type.

#     Objects of protected types are preserved as-is when passed to
#     force_str(strings_only=True).
#     """
#     return isinstance(obj, PROTECTED_TYPES)


# def mask_hash(hash: str, show: int = 6, char: str = "*") -> str:
#     """
#     Return the given hash, with only the first ``show`` number shown. The
#     rest are masked with ``char`` for security reasons.
#     """
#     masked = hash[:show]
#     masked += char * len(hash[show:])
#     return masked


# def must_update_salt(salt: str, expected_entropy: int) -> bool:
#     # Each character in the salt provides log_2(len(alphabet)) bits of entropy.
#     return len(salt) * math.log2(len(RANDOM_STRING_CHARS)) < expected_entropy


# class PBKDF2PasswordHasher:
#     """
#     Secure password hashing using the PBKDF2 algorithm (recommended)

#     Configured to use PBKDF2 + HMAC + SHA256.
#     The result is a 64 byte binary string.  Iterations may be changed
#     safely but you must rename the algorithm if you change SHA256.
#     """

#     algorithm = "pbkdf2_sha256"
#     library = None
#     salt_entropy = 128
#     iterations = 260000
#     digest = hashlib.sha256

#     def salt(self: "PBKDF2PasswordHasher") -> str:
#         """
#         Generate a cryptographically secure nonce salt in ASCII with an entropy
#         of at least `salt_entropy` bits.
#         """
#         # Each character in the salt provides
#         # log_2(len(alphabet)) bits of entropy.
#         char_count = math.ceil(self.salt_entropy / math.log2(len(RANDOM_STRING_CHARS)))
#         return get_random_string(char_count, allowed_chars=RANDOM_STRING_CHARS)

#     def encode(self: "PBKDF2PasswordHasher", password: str, salt: str, iterations: Optional[int] = None) -> str:
#         assert password is not None
#         assert salt and "$" not in salt
#         iterations = iterations or self.iterations
#         hash = self.pbkdf2(password, salt, iterations, digest=self.digest)
#         hash = base64.b64encode(hash).decode("ascii").strip()
#         return "%s$%d$%s$%s" % (self.algorithm, iterations, salt, hash)

#     def decode(self: "PBKDF2PasswordHasher", encoded: str) -> Dict[str, Any]:
#         algorithm, iterations, salt, hash = encoded.split("$", 3)
#         assert algorithm == self.algorithm
#         return {
#             "algorithm": algorithm,
#             "hash": hash,
#             "iterations": int(iterations),
#             "salt": salt,
#         }

#     def verify(self: "PBKDF2PasswordHasher", password: str, encoded: str) -> bool:
#         if not encoded:
#             return False
#         decoded = self.decode(encoded)
#         encoded_2 = self.encode(password, decoded["salt"], decoded["iterations"])
#         return constant_time_compare(encoded, encoded_2)

#     def safe_summary(self: "PBKDF2PasswordHasher", encoded: str) -> Dict[str, str]:
#         decoded = self.decode(encoded)
#         return {
#             "algorithm": decoded["algorithm"],
#             "iterations": decoded["iterations"],
#             "salt": mask_hash(decoded["salt"]),
#             "hash": mask_hash(decoded["hash"]),
#         }

#     def must_update(self: "PBKDF2PasswordHasher", encoded: str) -> bool:
#         decoded = self.decode(encoded)
#         update_salt = must_update_salt(decoded["salt"], self.salt_entropy)
#         return (decoded["iterations"] != self.iterations) or update_salt

#     def pbkdf2(self: "PBKDF2PasswordHasher", password: str, salt: str, iterations: int, dklen=0, digest=None) -> bytes:
#         """Return the hash of password using pbkdf2."""
#         if digest is None:
#             digest = hashlib.sha256
#         dklen = dklen or None
#         password = force_bytes(password)
#         salt = force_bytes(salt)
#         return hashlib.pbkdf2_hmac(digest().name, password, salt, iterations, dklen)


# if __name__ == "__main__":
#     assert check_password("cga7ozYGjNj5Tf", "pbkdf2_sha256$100000$hG2AqBfzrw95$3bkeN1BOo4fwcvL1IrhDBYYVcYUDfsbD3fKaROy16eM=")
